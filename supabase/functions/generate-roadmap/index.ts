import { serve } from "https://deno.land/std@0.168.0/http/server.ts"
import { corsHeaders } from '../_shared/cors.ts'

// --- Gemini API Configuration ---
// IMPORTANT: Store your Gemini API Key securely as a Supabase Secret:
// Go to Project Settings > Edge Functions > Add new secret > Name: GEMINI_API_KEY, Value: your_api_key
const GEMINI_API_KEY = Deno.env.get("GEMINI_API_KEY");
// Choose the appropriate Gemini model
const GEMINI_MODEL = "gemini-1.5-flash-latest"; // Or another suitable model
const GEMINI_API_URL = `https://generativelanguage.googleapis.com/v1beta/models/${GEMINI_MODEL}:generateContent?key=${GEMINI_API_KEY}`;

// --- Helper: Basic Response Parsing (Needs Refinement!) ---
// This is a VERY basic parser. You'll likely need a more robust 
// approach based on the exact Gemini output format and desired structure.
// Consider asking Gemini to respond in JSON format directly if possible.
function parseGeminiResponse(text: string): { 
  title: string, 
  description: string,
  prerequisites: string[],
  learningObjectives: string[],
  steps: any[],
  additionalResources: string[],
  motivationTips: string[],
  nextSteps: string[]
} {
  // First, clean the text of any markdown formatting
  text = text.replace(/\*\*/g, '');
  text = text.replace(/\*/g, '');
  text = text.replace(/_/g, '');
  
  const lines = text.split('\n').map(l => l.trim()).filter(Boolean);
  let title = "AI Generated Roadmap";
  let description = "A comprehensive roadmap generated by AI.";
  let prerequisites: string[] = [];
  let learningObjectives: string[] = [];
  let additionalResources: string[] = [];
  let motivationTips: string[] = [];
  let nextSteps: string[] = [];
  const steps: any[] = [];
  let currentStep: any = null;
  let currentSection = '';

  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    
    // Detect section headers
    if (line.startsWith('TITLE:')) {
      title = line.replace('TITLE:', '').trim();
      continue;
    }
    if (line.startsWith('DESCRIPTION:')) {
      description = line.replace('DESCRIPTION:', '').trim();
      continue;
    }
    if (line === 'PREREQUISITES:') {
      currentSection = 'prerequisites';
      continue;
    }
    if (line === 'LEARNING OBJECTIVES:') {
      currentSection = 'objectives';
      continue;
    }
    if (line === 'STEPS:') {
      currentSection = 'steps';
      continue;
    }
    if (line === 'ADDITIONAL RESOURCES:') {
      currentSection = 'resources';
      continue;
    }
    if (line === 'MOTIVATION TIPS:') {
      currentSection = 'motivation';
      continue;
    }
    if (line === 'NEXT STEPS:') {
      currentSection = 'next';
      continue;
    }

    // Process content based on current section
    switch (currentSection) {
      case 'prerequisites':
        if (line.startsWith('-')) {
          prerequisites.push(line.replace('-', '').trim());
        }
        break;
      case 'objectives':
        if (line.startsWith('-')) {
          learningObjectives.push(line.replace('-', '').trim());
        }
        break;
      case 'steps':
        const stepMatch = line.match(/^Step (\d+):\s*(.*)/i);
        if (stepMatch) {
          if (currentStep) {
            // Validate the current step before adding it
            if (currentStep.title && currentStep.description && currentStep.estimated_time) {
              steps.push(currentStep);
            } else {
              console.warn("Incomplete step found:", currentStep);
            }
          }
          currentStep = {
            title: stepMatch[2].trim(),
            description: '',
            estimated_time: '',
            resources: [],
            exercises: [],
            concepts: [],
            pitfalls: [],
            metrics: []
          };
        } else if (currentStep) {
          if (line.startsWith('Description:')) {
            currentStep.description = line.replace('Description:', '').trim();
          } else if (line.startsWith('Time:')) {
            currentStep.estimated_time = line.replace('Time:', '').trim();
          } else if (line.startsWith('Resources:')) {
            currentStep.resources = line.replace('Resources:', '').split(',').map(r => r.trim()).filter(Boolean);
          } else if (line.startsWith('Exercises:')) {
            currentStep.exercises = line.replace('Exercises:', '').split(',').map(e => e.trim()).filter(Boolean);
          } else if (line.startsWith('Concepts:')) {
            currentStep.concepts = line.replace('Concepts:', '').split(',').map(c => c.trim()).filter(Boolean);
          } else if (line.startsWith('Pitfalls:')) {
            currentStep.pitfalls = line.replace('Pitfalls:', '').split(',').map(p => p.trim()).filter(Boolean);
          } else if (line.startsWith('Metrics:')) {
            currentStep.metrics = line.replace('Metrics:', '').split(',').map(m => m.trim()).filter(Boolean);
          }
        }
        break;
      case 'resources':
        if (line.startsWith('-')) {
          additionalResources.push(line.replace('-', '').trim());
        }
        break;
      case 'motivation':
        if (line.startsWith('-')) {
          motivationTips.push(line.replace('-', '').trim());
        }
        break;
      case 'next':
        if (line.startsWith('-')) {
          nextSteps.push(line.replace('-', '').trim());
        }
        break;
    }
  }

  // Add the last step if exists and is valid
  if (currentStep && currentStep.title && currentStep.description && currentStep.estimated_time) {
    steps.push(currentStep);
  }

  // Validate that we have the required number of steps
  if (steps.length < 5) {
    console.error(`Expected 5 steps but got ${steps.length}`);
    throw new Error("Insufficient number of steps generated");
  }

  return {
    title,
    description,
    prerequisites,
    learningObjectives,
    steps,
    additionalResources,
    motivationTips,
    nextSteps
  };
}

// --- Edge Function Handler ---
serve(async (req) => {
  // Handle CORS preflight requests
  if (req.method === 'OPTIONS') {
    return new Response('ok', { headers: corsHeaders });
  }

  try {
    // 1. Get preferences from the request body
    const { pathName, level, language, customPrompt } = await req.json();
    console.log('Received request:', { pathName, level, language });

    if (!pathName || !level || !language) {
      console.error('Missing required parameters:', { pathName, level, language });
      return new Response(JSON.stringify({ error: "Missing required parameters" }), {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        status: 400,
      });
    }

    if (!GEMINI_API_KEY) {
      console.error('GEMINI_API_KEY is not set');
      throw new Error("GEMINI_API_KEY is not set in Supabase secrets.");
    }

    // 2. Construct the prompt for Gemini
    const basePrompt = `Create a comprehensive learning roadmap for a user wanting to learn "${pathName}" at an "${level}" level. The user's preferred learning language is "${language}".

    IMPORTANT: You MUST follow this exact format. Do not deviate from it:

    TITLE: [Your catchy title here]

    DESCRIPTION: [Your detailed description here]

    PREREQUISITES:
    - [Prerequisite 1]
    - [Prerequisite 2]

    LEARNING OBJECTIVES:
    - [Objective 1]
    - [Objective 2]

    STEPS:

    Step 1: [Step Title]
    Description: [Detailed description of what will be learned]
    Time: [Estimated time to complete]
    Resources: [List of resources]
    Exercises: [Practice exercises or projects]
    Concepts: [Key concepts to master]
    Pitfalls: [Common mistakes to avoid]
    Metrics: [Success criteria]

    Step 2: [Step Title]
    Description: [Detailed description of what will be learned]
    Time: [Estimated time to complete]
    Resources: [List of resources]
    Exercises: [Practice exercises or projects]
    Concepts: [Key concepts to master]
    Pitfalls: [Common mistakes to avoid]
    Metrics: [Success criteria]

    Step 3: [Step Title]
    Description: [Detailed description of what will be learned]
    Time: [Estimated time to complete]
    Resources: [List of resources]
    Exercises: [Practice exercises or projects]
    Concepts: [Key concepts to master]
    Pitfalls: [Common mistakes to avoid]
    Metrics: [Success criteria]

    Step 4: [Step Title]
    Description: [Detailed description of what will be learned]
    Time: [Estimated time to complete]
    Resources: [List of resources]
    Exercises: [Practice exercises or projects]
    Concepts: [Key concepts to master]
    Pitfalls: [Common mistakes to avoid]
    Metrics: [Success criteria]

    Step 5: [Step Title]
    Description: [Detailed description of what will be learned]
    Time: [Estimated time to complete]
    Resources: [List of resources]
    Exercises: [Practice exercises or projects]
    Concepts: [Key concepts to master]
    Pitfalls: [Common mistakes to avoid]
    Metrics: [Success criteria]

    ADDITIONAL RESOURCES:
    - [Resource 1]
    - [Resource 2]

    MOTIVATION TIPS:
    - [Tip 1]
    - [Tip 2]

    NEXT STEPS:
    - [Next step 1]
    - [Next step 2]

    Remember:
    1. You MUST include exactly 5 steps
    2. Each step MUST follow the exact format above
    3. Each step MUST have all fields (Description, Time, Resources, etc.)
    4. Do not add any extra text or explanations outside this format`;

    const finalPrompt = customPrompt ? `${basePrompt}\n\nUser refinement: ${customPrompt}` : basePrompt;

    console.log("Sending prompt to Gemini:", finalPrompt);

    // 3. Call the Gemini API
    const geminiPayload = {
      contents: [
        { parts: [{ text: finalPrompt }] }
      ],
      generationConfig: {
        temperature: 0.2, // Lower temperature for more consistent output
        maxOutputTokens: 2048,
        topP: 0.8,
        topK: 40
      }
    };

    console.log("Making request to Gemini API...");
    const geminiRes = await fetch(GEMINI_API_URL, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(geminiPayload),
    });

    if (!geminiRes.ok) {
      const errorBody = await geminiRes.text();
      console.error("Gemini API Error Response:", errorBody);
      throw new Error(`Gemini API request failed: ${geminiRes.status} ${geminiRes.statusText}`);
    }

    const geminiData = await geminiRes.json();
    console.log("Raw Gemini response:", JSON.stringify(geminiData, null, 2));

    // 4. Parse the Gemini response
    let generatedText = '';
    
    try {
      // Try different possible response structures
      if (geminiData?.candidates?.[0]?.content?.parts?.[0]?.text) {
        generatedText = geminiData.candidates[0].content.parts[0].text;
      } else if (geminiData?.text) {
        generatedText = geminiData.text;
      } else if (geminiData?.response) {
        generatedText = geminiData.response;
      } else {
        console.error("Unexpected Gemini response structure:", geminiData);
        throw new Error("Could not find text content in Gemini response");
      }

      // Log the raw text before cleaning
      console.log("Raw Gemini text before cleaning:", generatedText);

      // Remove any markdown formatting
      generatedText = generatedText.replace(/\*\*/g, '');
      generatedText = generatedText.replace(/\*/g, '');
      generatedText = generatedText.replace(/_/g, '');
      
      console.log("Cleaned generated text:", generatedText);
    } catch (error) {
      console.error("Error processing Gemini response:", error);
      throw new Error(`Failed to process Gemini response: ${error.message}`);
    }

    if (!generatedText) {
      console.error("Generated text is empty after processing");
      throw new Error("Failed to extract content from Gemini response.");
    }

    const structuredRoadmap = parseGeminiResponse(generatedText);
    console.log("Parsed roadmap:", JSON.stringify(structuredRoadmap, null, 2));

    // Validate the parsed roadmap
    if (!structuredRoadmap.steps || structuredRoadmap.steps.length === 0) {
      console.error("No steps found in parsed roadmap");
      throw new Error("Failed to generate valid roadmap steps");
    }

    if (structuredRoadmap.steps.length < 5) {
      console.error(`Expected 5 steps but got ${structuredRoadmap.steps.length}`);
      throw new Error("Insufficient number of steps generated");
    }

    // 5. Return the structured roadmap
    return new Response(
      JSON.stringify(structuredRoadmap),
      {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        status: 200,
      },
    );
  } catch (error) {
    console.error("Error in Edge Function:", error);
    return new Response(JSON.stringify({ error: error.message }), {
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      status: 500,
    });
  }
}); 