import { serve } from "https://deno.land/std@0.168.0/http/server.ts"
import { corsHeaders } from '../_shared/cors.ts'

// --- Gemini API Configuration ---
// IMPORTANT: Store your Gemini API Key securely as a Supabase Secret:
// Go to Project Settings > Edge Functions > Add new secret > Name: GEMINI_API_KEY, Value: your_api_key
const GEMINI_API_KEY = Deno.env.get("GEMINI_API_KEY");
// Choose the appropriate Gemini model
const GEMINI_MODEL = "gemini-1.5-flash-latest"; // Or another suitable model
const GEMINI_API_URL = `https://generativelanguage.googleapis.com/v1beta/models/${GEMINI_MODEL}:generateContent?key=${GEMINI_API_KEY}`;

// --- Helper: Basic Response Parsing (Needs Refinement!) ---
// This is a VERY basic parser. You'll likely need a more robust 
// approach based on the exact Gemini output format and desired structure.
// Consider asking Gemini to respond in JSON format directly if possible.
function parseGeminiResponse(text: string): { title: string, description: string, steps: any[] } {
  const lines = text.split('\n').map(l => l.trim()).filter(Boolean);
  let title = "AI Generated Roadmap";
  let description = "A roadmap generated by AI.";
  const steps: any[] = [];
  let currentStep: any = null;
  let stepIndex = 0;

  // Try to extract title and description if they are formatted clearly
  if (lines[0] && !lines[0].toLowerCase().startsWith('step') && !lines[0].toLowerCase().startsWith('1.')) {
    title = lines.shift() || title;
  }
  if (lines[0] && !lines[0].toLowerCase().startsWith('step') && !lines[0].toLowerCase().startsWith('1.')) {
    description = lines.shift() || description;
  }

  lines.forEach(line => {
    const stepMatch = line.match(/^(?:step\s*\d+|\d+)\s*[:.\-]?\s*(.*)/i);
    const timeMatch = line.match(/(?:time|duration|estimated)[:\s]+(.*)/i);
    const keywordsMatch = line.match(/(?:keywords|tags)[:\s]+(.*)/i);

    if (stepMatch) {
      if (currentStep) {
        steps.push({ ...currentStep, order_index: stepIndex++ });
      }
      currentStep = {
        title: stepMatch[1].trim(),
        description: '', // Reset description for new step
        estimated_time: 'N/A', // Default time
        keywords: [], // Default keywords
      };
    } else if (timeMatch && currentStep) {
      currentStep.estimated_time = timeMatch[1].trim();
    } else if (keywordsMatch && currentStep) {
      currentStep.keywords = keywordsMatch[1].split(',').map(k => k.trim()).filter(Boolean);
    } else if (currentStep && currentStep.title) {
      // Append lines to the description if they don't match other patterns
      currentStep.description = (currentStep.description ? currentStep.description + ' ' : '') + line;
    }
  });

  // Add the last step
  if (currentStep) {
    steps.push({ ...currentStep, order_index: stepIndex++ });
  }

  // Fallback if parsing fails
  if (steps.length === 0) {
    console.warn("Failed to parse steps from Gemini response:", text);
    return {
      title: "Default Roadmap",
      description: "Could not parse AI response, using default.",
      steps: [
        { title: 'Step 1', description: 'Review AI response manually.', order_index: 0, estimated_time: '1 hour', keywords: ['debug'] },
      ]
    };
  }

  return { title, description, steps };
}

// --- Edge Function Handler ---
serve(async (req) => {
  // Handle CORS preflight requests
  if (req.method === 'OPTIONS') {
    return new Response('ok', { headers: corsHeaders });
  }

  try {
    // 1. Get preferences from the request body
    const { pathName, level, language, customPrompt } = await req.json();
    console.log('Received request:', { pathName, level, language });

    if (!pathName || !level || !language) {
      return new Response(JSON.stringify({ error: "Missing required parameters" }), {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        status: 400,
      });
    }

    if (!GEMINI_API_KEY) {
        throw new Error("GEMINI_API_KEY is not set in Supabase secrets.");
    }

    // 2. Construct the prompt for Gemini
    //    * Refine this prompt for better results! *
    //    * Consider asking for JSON output directly! *
    const basePrompt = `Create a detailed learning roadmap for a user wanting to learn "${pathName}" at an "${level}" level. The user's preferred learning language is "${language}".
    The roadmap should include a suitable title, a brief overall description, and 5-8 distinct steps.
    For each step, provide:
    - A clear title (e.g., "Step 1: HTML Basics Review")
    - A concise description of the topics or tasks involved.
    - An estimated time to complete the step (e.g., "2 hours", "3 days", "1 week").
    - A few relevant keywords or tags (comma-separated, e.g., "Keywords: HTML structure, elements, attributes").
    
    Format each step clearly, starting with "Step X:" or "X."`;

    const finalPrompt = customPrompt ? `${basePrompt}\n\nUser refinement: ${customPrompt}` : basePrompt;

    console.log("Sending prompt to Gemini:", finalPrompt);

    // 3. Call the Gemini API
    const geminiPayload = {
      contents: [
        { parts: [{ text: finalPrompt }] }
      ],
      // Add generationConfig if needed (temperature, max tokens, etc.)
      // generationConfig: {
      //   temperature: 0.7,
      //   maxOutputTokens: 1024,
      // }
    };

    const geminiRes = await fetch(GEMINI_API_URL, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(geminiPayload),
    });

    if (!geminiRes.ok) {
        const errorBody = await geminiRes.text();
        console.error("Gemini API Error Response:", errorBody);
        throw new Error(`Gemini API request failed: ${geminiRes.status} ${geminiRes.statusText}`);
    }

    const geminiData = await geminiRes.json();
    console.log("Received raw response from Gemini:", JSON.stringify(geminiData));

    // 4. Parse the Gemini response
    //    Accessing the text based on common Gemini API response structure
    const generatedText = geminiData?.candidates?.[0]?.content?.parts?.[0]?.text;

    if (!generatedText) {
      console.error("Could not extract text from Gemini response:", geminiData);
      throw new Error("Failed to extract content from Gemini response.");
    }

    console.log("Extracted text:", generatedText);
    const structuredRoadmap = parseGeminiResponse(generatedText);
    console.log("Parsed roadmap:", structuredRoadmap);

    // 5. Return the structured roadmap
    return new Response(
      JSON.stringify(structuredRoadmap),
      {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        status: 200,
      },
    );
  } catch (error) {
    console.error("Error in Edge Function:", error);
    return new Response(JSON.stringify({ error: error.message }), {
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      status: 500,
    });
  }
}); 